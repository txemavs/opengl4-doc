
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>function glMemoryBarrier &mdash; OpenGL documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="OpenGL documentation" href="../../../index.html" />
    <link rel="up" title="OpenGL v.4 Reference" href="../../../index_man4.html" />
    <link rel="next" title="function glMinSampleShading" href="glMinSampleShading.html" />
    <link rel="prev" title="function glMapBufferRange" href="glMapBufferRange.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="glMinSampleShading.html" title="function glMinSampleShading"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="glMapBufferRange.html" title="function glMapBufferRange"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">[]</a> &raquo;</li>
          <li><a href="../../../index_man4.html" accesskey="U">OpenGL v.4 Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="function-glmemorybarrier">
<h1>function <cite>glMemoryBarrier</cite><a class="headerlink" href="#function-glmemorybarrier" title="Permalink to this headline">¶</a></h1>
<div class="figure align-right">
<img alt="OpenGL" src="../../../_images/opengl.png" />
<p class="caption">Version 4 Vol. 3G</p>
</div>
<p>Defines a barrier ordering memory transactions</p>
<dl class="function">
<dt id="glMemoryBarrier">
<tt class="descname">glMemoryBarrier</tt><big>(</big><big>)</big><a class="headerlink" href="#glMemoryBarrier" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>barriers</strong> &#8211; Specifies the barriers to insert. Must be a bitwise combination of <tt class="docutils literal"><span class="pre">GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT</span></tt>,
<tt class="docutils literal"><span class="pre">GL_ELEMENT_ARRAY_BARRIER_BIT</span></tt>, <tt class="docutils literal"><span class="pre">GL_UNIFORM_BARRIER_BIT</span></tt>, <tt class="docutils literal"><span class="pre">GL_TEXTURE_FETCH_BARRIER_BIT</span></tt>,
<tt class="docutils literal"><span class="pre">GL_SHADER_IMAGE_ACCESS_BARRIER_BIT</span></tt>, <tt class="docutils literal"><span class="pre">GL_COMMAND_BARRIER_BIT</span></tt>, <tt class="docutils literal"><span class="pre">GL_PIXEL_BUFFER_BARRIER_BIT</span></tt>,
<tt class="docutils literal"><span class="pre">GL_TEXTURE_UPDATE_BARRIER_BIT</span></tt>, <tt class="docutils literal"><span class="pre">GL_BUFFER_UPDATE_BARRIER_BIT</span></tt>,
<tt class="docutils literal"><span class="pre">GL_FRAMEBUFFER_BARRIER_BIT</span></tt>, <tt class="docutils literal"><span class="pre">GL_TRANSFORM_FEEDBACK_BARRIER_BIT</span></tt> or <tt class="docutils literal"><span class="pre">GL_ATOMIC_COUNTER_BARRIER_BIT</span></tt>.
If the special value <tt class="docutils literal"><span class="pre">GL_ALL_BARRIER_BITS</span></tt> is specified, all supported barriers will be inserted.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p class="rubric">Specification</p>
<dl class="function">
<dt>
void <tt class="descname">glMemoryBarrier</tt><big>(</big>GLbitfield <em>&nbsp;barriers</em><big>)</big></dt>
<dd></dd></dl>

<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="glBindImageTexture.html#glBindImageTexture" title="glBindImageTexture"><tt class="xref c c-func docutils literal"><span class="pre">glBindImageTexture()</span></tt></a>,
<a class="reference internal" href="glBufferData.html#glBufferData" title="glBufferData"><tt class="xref c c-func docutils literal"><span class="pre">glBufferData()</span></tt></a>,
<a class="reference internal" href="glMapBuffer.html#glMapBuffer" title="glMapBuffer"><tt class="xref c c-func docutils literal"><span class="pre">glMapBuffer()</span></tt></a>,
<a class="reference internal" href="glMapBufferRange.html#glMapBufferRange" title="glMapBufferRange"><tt class="xref c c-func docutils literal"><span class="pre">glMapBufferRange()</span></tt></a>,
<a class="reference internal" href="glFlushMappedBufferRange.html#glFlushMappedBufferRange" title="glFlushMappedBufferRange"><tt class="xref c c-func docutils literal"><span class="pre">glFlushMappedBufferRange()</span></tt></a></p>
</div>
<p class="rubric">Description</p>
<p><a class="reference internal" href="#glMemoryBarrier" title="glMemoryBarrier"><tt class="xref c c-func docutils literal"><span class="pre">glMemoryBarrier()</span></tt></a> defines a barrier ordering the memory transactions issued prior to the
command relative to those issued after the barrier. For the purposes of
this ordering, memory transactions performed by shaders are considered to
be issued by the rendering command that triggered the execution of the
shader. <em>barriers</em> is a bitfield indicating the set of operations that
are synchronized with shader stores; the bits used in <em>barriers</em> are as
follows:</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT</span></tt></p>
<blockquote>
<div>If set, vertex data sourced from
buffer objects after the barrier will reflect data written by shaders
prior to the barrier.  The set of buffer objects affected by this bit
is derived from the buffer object bindings used for
generic vertex attributes derived from the <tt class="docutils literal"><span class="pre">GL_VERTEX_ATTRIB_ARRAY_BUFFER</span></tt> bindings.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_ELEMENT_ARRAY_BARRIER_BIT</span></tt></p>
<blockquote>
<div>If set, vertex array indices sourced from
buffer objects after the barrier will reflect data written by shaders
prior to the barrier.  The buffer objects affected by this bit are
derived from the <tt class="docutils literal"><span class="pre">GL_ELEMENT_ARRAY_BUFFER</span></tt> binding.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_UNIFORM_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Shader uniforms sourced from buffer objects after the barrier will reflect data
written by shaders prior to the barrier.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_TEXTURE_FETCH_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Texture fetches from shaders, including
fetches from buffer object memory via buffer textures, after the
barrier will reflect data written by shaders prior to the barrier.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_SHADER_IMAGE_ACCESS_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Memory accesses using shader image
load, store, and atomic built-in functions issued after the barrier
will reflect data written by shaders prior to the barrier.
Additionally, image stores and atomics issued after the barrier will
not execute until all memory accesses (e.g., loads, stores, texture
fetches, vertex fetches) initiated prior to the barrier complete.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_COMMAND_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Command data sourced from buffer objects by
Draw*Indirect commands after the barrier will reflect data written by
shaders prior to the barrier.  The buffer objects affected by this bit
are derived from the <tt class="docutils literal"><span class="pre">GL_DRAW_INDIRECT_BUFFER</span></tt> binding.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_PIXEL_BUFFER_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Reads and writes of buffer objects via the
<tt class="docutils literal"><span class="pre">GL_PIXEL_PACK_BUFFER</span></tt> and <tt class="docutils literal"><span class="pre">GL_PIXEL_UNPACK_BUFFER</span></tt>
bindings (via <a class="reference internal" href="glReadPixels.html#glReadPixels" title="glReadPixels"><tt class="xref c c-func docutils literal"><span class="pre">glReadPixels()</span></tt></a>,
<tt class="xref c c-func docutils literal"><span class="pre">glTexSubImage()</span></tt>, etc.) after the
barrier will reflect data written by shaders prior to the barrier.
Additionally, buffer object writes issued after the barrier will wait
on the completion of all shader writes initiated prior to the barrier.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_TEXTURE_UPDATE_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Writes to a texture via <tt class="xref c c-func docutils literal"><span class="pre">glTex(Sub)Image*()</span></tt>,
<tt class="xref c c-func docutils literal"><span class="pre">glCopyTex(Sub)Image*()</span></tt>, <tt class="xref c c-func docutils literal"><span class="pre">glCompressedTex(Sub)Image*()</span></tt>, and reads via
<a class="reference internal" href="glGetTexImage.html#glGetTexImage" title="glGetTexImage"><tt class="xref c c-func docutils literal"><span class="pre">glGetTexImage()</span></tt></a> after the barrier will reflect data written by shaders
prior to the barrier.  Additionally, texture writes from these
commands issued after the barrier will not execute until all shader
writes initiated prior to the barrier complete.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_BUFFER_UPDATE_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Reads or writes via <a class="reference internal" href="glBufferSubData.html#glBufferSubData" title="glBufferSubData"><tt class="xref c c-func docutils literal"><span class="pre">glBufferSubData()</span></tt></a>,
<a class="reference internal" href="glCopyBufferSubData.html#glCopyBufferSubData" title="glCopyBufferSubData"><tt class="xref c c-func docutils literal"><span class="pre">glCopyBufferSubData()</span></tt></a>,
or <a class="reference internal" href="glGetBufferSubData.html#glGetBufferSubData" title="glGetBufferSubData"><tt class="xref c c-func docutils literal"><span class="pre">glGetBufferSubData()</span></tt></a>, or
to buffer object memory mapped by <a class="reference internal" href="glMapBuffer.html#glMapBuffer" title="glMapBuffer"><tt class="xref c c-func docutils literal"><span class="pre">glMapBuffer()</span></tt></a>
or <a class="reference internal" href="glMapBufferRange.html#glMapBufferRange" title="glMapBufferRange"><tt class="xref c c-func docutils literal"><span class="pre">glMapBufferRange()</span></tt></a> after the barrier
will reflect data written by shaders prior to the barrier.
Additionally, writes via these commands issued after the barrier will
wait on the completion of any shader writes to the same memory
initiated prior to the barrier.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_FRAMEBUFFER_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Reads and writes via framebuffer object
attachments after the barrier will reflect data written by shaders
prior to the barrier.  Additionally, framebuffer writes issued after
the barrier will wait on the completion of all shader writes issued
prior to the barrier.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_TRANSFORM_FEEDBACK_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Writes via transform feedback
bindings after the barrier will reflect data written by shaders prior
to the barrier.  Additionally, transform feedback writes issued after
the barrier will wait on the completion of all shader writes issued
prior to the barrier.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">GL_ATOMIC_COUNTER_BARRIER_BIT</span></tt></p>
<blockquote>
<div>Accesses to atomic counters after the
barrier will reflect writes prior to the barrier.</div></blockquote>
</div></blockquote>
<p>If <em>barriers</em> is <tt class="docutils literal"><span class="pre">GL_ALL_BARRIER_BITS</span></tt>, shader memory accesses
will be synchronized relative to all the operations described above.</p>
<p>Implementations may cache buffer object and texture image memory that
could be written by shaders in multiple caches; for example, there may be
separate caches for texture, vertex fetching, and one or more caches for
shader memory accesses.  Implementations are not required to keep these
caches coherent with shader memory writes.  Stores issued by one
invocation may not be immediately observable by other pipeline stages or
other shader invocations because the value stored may remain in a cache
local to the processor executing the store, or because data overwritten by
the store is still in a cache elsewhere in the system.  When <a class="reference internal" href="#glMemoryBarrier" title="glMemoryBarrier"><tt class="xref c c-func docutils literal"><span class="pre">glMemoryBarrier()</span></tt></a>
is called, the GL flushes and/or invalidates any caches relevant to the
operations specified by the <em>barriers</em> parameter to ensure consistent
ordering of operations across the barrier.</p>
<p>To allow for independent shader invocations to communicate by reads and
writes to a common memory address, image variables in the OpenGL Shading
Language may be declared as &#8220;coherent&#8221;.  Buffer object or texture image
memory accessed through such variables may be cached only if caches are
automatically updated due to stores issued by any other shader invocation.
If the same address is accessed using both coherent and non-coherent
variables, the accesses using variables declared as coherent will observe
the results stored using coherent variables in other invocations.  Using
variables declared as &#8220;coherent&#8221; guarantees only that the results of
stores will be immediately visible to shader invocations using
similarly-declared variables; calling <a class="reference internal" href="#glMemoryBarrier" title="glMemoryBarrier"><tt class="xref c c-func docutils literal"><span class="pre">glMemoryBarrier()</span></tt></a> is required to ensure
that the stores are visible to other operations.</p>
<p>The following guidelines may be helpful in choosing when to use coherent
memory accesses and when to use barriers.</p>
<blockquote>
<div><ul class="simple">
<li>Data that are read-only or constant may be accessed without using coherent variables or calling MemoryBarrier(). Updates to the read-only data via API calls such as BufferSubData will invalidate shader caches implicitly as required.</li>
<li>Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another invocation) should use coherent variables to read and write the shared data.</li>
<li>Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution (&#8220;dependent invocations&#8221;) should use coherent variables in the producing shader invocation and call memoryBarrier() after the last write. The consuming shader invocation should also use coherent variables.</li>
<li>Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables or memoryBarrier(). Calling MemoryBarrier() with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in <em>barriers</em> between passes is necessary.</li>
<li>Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent variables or memoryBarrier(). Calling <a class="reference internal" href="#glMemoryBarrier" title="glMemoryBarrier"><tt class="xref c c-func docutils literal"><span class="pre">glMemoryBarrier()</span></tt></a> with the appropriate bits set in <em>barriers</em> between passes is necessary.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="#glMemoryBarrier" title="glMemoryBarrier"><tt class="xref c c-func docutils literal"><span class="pre">glMemoryBarrier()</span></tt></a> is available only if the GL version is 4.2 or higher.</p>
</div>
<p><strong>Errors:</strong></p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">GL_INVALID_VALUE</span></tt> is generated if <em>barriers</em> contains any bits other than those listed above, or is not the special value <tt class="docutils literal"><span class="pre">GL_ALL_BARRIER_BITS</span></tt>.</li>
</ul>
<div class="figure align-right">
<img alt="OpenGL" src="../../../_images/opengl.png" />
<p class="caption">(c)2011 Khronos Group. Open Publication License.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="glMapBufferRange.html"
                        title="previous chapter">function <cite>glMapBufferRange</cite></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="glMinSampleShading.html"
                        title="next chapter">function <cite>glMinSampleShading</cite></a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../_sources/api/OpenGL/man4/glMemoryBarrier.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="glMinSampleShading.html" title="function glMinSampleShading"
             >next</a> |</li>
        <li class="right" >
          <a href="glMapBufferRange.html" title="function glMapBufferRange"
             >previous</a> |</li>
        <li><a href="../../../index.html">[]</a> &raquo;</li>
          <li><a href="../../../index_man4.html" >OpenGL v.4 Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009 Khronos Group.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>